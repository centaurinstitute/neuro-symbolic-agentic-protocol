# NSAI-0012 Exception Handling and Constraints

## Description

NSAIP extends Python's exception handling model to work with the declarative runtime and transactional execution model. The `ConstraintViolationError` exception is raised when declarative constraints or assertions are violated during updates. When combined with declarative conditional statements, this enables the expression of logical constraints that are automatically enforced throughout program execution. If a constraint is violated, the transaction rolls back to maintain consistency.

## Examples

```python
class Account:
    def __init__(self, balance):
        self.balance = balance
```

### Declarative constraint definition

```python
if Account.balance < 0:
    raise ConstraintViolationError("Balance cannot be negative")
```

```python
account1 = Account(100)
```

```python
> account1.balance
100
```

### Constraint violation triggers exception

```python
account1.balance = -50
# ConstraintViolationError: Balance cannot be negative
```

The declarative constraint automatically monitors all instances of the `Account` class. When `balance` is set to a negative value, the constraint is violated and the exception is raised, preventing invalid state.

### Other logic exceptions

**CircularDependencyError**: Raised when the dependency graph contains cycles
```python
a = b + 1
b = a + 1  # CircularDependencyError: Circular dependency detected
```

**PropagationError**: Raised when dependency updates fail during recalculation
```python
# PropagationError: Failed to propagate changes through dependency graph
```

**GraphConsistencyError**: Raised when internal graph invariants are violated
```python
# GraphConsistencyError: Logic Graph entered inconsistent state
```
